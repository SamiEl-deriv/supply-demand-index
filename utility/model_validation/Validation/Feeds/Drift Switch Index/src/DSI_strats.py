import pandas as pd
import numpy as np
from utils import timer
import matplotlib.pyplot as plt

def perfect_twosided(df_feed, delay = 0) -> pd.DataFrame:
    """
    Backtests the perfect trading strategy as follows:
    
    * If DSI_state = 1, close position
    * If DSI_state = 0, open long position and close previous short position if necessary
    * If DSI_state = 2, open short position and close previous long position if necessary

    No open trades can be left at the end

    If delay is positive, simulate obtaining the state feed late, i.e delay = 60 implies a minute delay to receive states

    Arguments
    ---------
    df_feed : pandas.DataFrame
        DSI feed generated by DSI.DSI_Engine
    delay : bool
        Delay of receiving states (in ticks)

    Returns
    -------
    pandas.DataFrame
        The dataframe of trades executed
    """
    ff = df_feed[['bid','ask','state']].copy()
    delayed_states = ff['state'].shift(delay)
    shifted_ff = delayed_states.shift(1)

    # Signal for change in states (Need to account for final trade not being closed position)
    ff['isLong']  = ((shifted_ff == 1) & (delayed_states == 0)) # neutral to up
    ff['isShort'] = ((shifted_ff == 1) & (delayed_states == 2)) # neutral to down
    ff['isCloseLong'] = ((shifted_ff == 0) & (delayed_states == 1)) # up to stationary
    ff['isCloseShort'] = ((shifted_ff == 2) & (delayed_states == 1))# down to stationary
    ff['isCloseLongtoShort'] = ((shifted_ff == 0) & (delayed_states == 2)) # up to down
    ff['isCloseShorttoLong'] = ((shifted_ff == 2) & (delayed_states == 0)) # down to up
    ff['isClose'] = ff['isCloseLong'] | ff['isCloseShort'] | ff['isCloseLongtoShort'] | ff['isCloseShorttoLong'] # closed positions
    # Make sure last trade is close, no opened trades at end
    closed = ff['isCloseLong'] | ff['isCloseShort']
    last_close =  closed[closed].index[-1]
    ff = ff[:last_close+1]

    # Filter
    position_changes = ff[ff['isLong'] | ff['isShort'] | ff['isCloseLong'] | ff['isCloseShort'] | ff['isCloseLongtoShort'] | ff['isCloseShorttoLong']]

    # Opening positions (buy ask price and sell bid price)
    position_changes.loc[:,'open'] = np.where(position_changes['isLong'] | position_changes['isCloseShorttoLong'], -position_changes['ask'], 
                                              np.where(position_changes['isShort'] | position_changes['isCloseLongtoShort'], position_changes['bid'], 0))
    
    # Closing positions (buy ask price and sell bid price)
    position_changes.loc[:,'close'] = np.where(position_changes['isCloseShort'] | position_changes['isCloseShorttoLong'], -position_changes['ask'], 
                                              np.where(position_changes['isCloseLong'] | position_changes['isCloseLongtoShort'], position_changes['bid'], 0))
    
    # Number of opened positions
    position_changes.loc[:,'num_trades'] = ff['isClose'].cumsum()

    # Aggregate pnl
    position_changes.loc[:,'pnl'] = np.where(position_changes['isCloseShort'] | position_changes['isCloseShorttoLong'] | position_changes['isCloseLong'] | position_changes['isCloseLongtoShort'], 
                                             position_changes['close'] + position_changes['open'].shift(1), 0)
    position_changes['cumulative_pnl'] = position_changes['pnl'].cumsum()
    position_changes.reset_index(inplace=True)
    position_changes.rename(columns={'index' : 'ts'}, inplace=True)

    position_changes['avg_pnl_per_trade'] = position_changes['cumulative_pnl']/position_changes.num_trades
    position_changes['avg_pnl_per_time'] = position_changes['cumulative_pnl']/position_changes.ts

    return position_changes

def run_twosided_perfect(df_feed, delay_range) -> dict[int, pd.DataFrame]:
    """
    Run the perfect strategy for a range of delays

    Arguments
    ---------
    df_feed : pandas.DataFrame
        DSI feed generated by DSI.DSI_Engine
    delay_range : list[int]
        The range of delays to test
    
    Returns
    -------
    dict[int, pd.DataFrame]
        A dict:
        * keys - delays
        * values - dataframes of trades executed
    """
    result = dict(zip(delay_range, np.zeros(len(delay_range))))
    for delay in delay_range:
        result[delay] = perfect_twosided(df_feed, delay)
    return result
        

def plot_multiple_delays(df_feed, delay_list, over_time=False):
    """
    Run the perfect strategy for a range of delays then plots the average pnl over delay

    Arguments
    ---------
    df_feed : pandas.DataFrame
        DSI feed generated by DSI.DSI_Engine
    delay_range : list[int]
        The range of delays to test
    over_time : bool
        If true, plots the average pnl per time, else plots the average pnl per trade. Defaults to False
    """
    dfs_trades = run_twosided_perfect(df_feed, delay_list)
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10,8))
    
    for delay in delay_list:
        df_trades = dfs_trades[delay]
        x_axis = df_trades['ts'] if over_time else df_trades.index
        ax1.plot(x_axis, df_trades['cumulative_pnl'])
        ax2.plot(x_axis, df_trades[f'avg_pnl_per_{"time" if over_time else "trade"}'])

    ax1.set_title(f'Cumulative pnl for delayed perfect strategies')
    ax2.set_title(f'Average pnl for delayed perfect strategies')

    ax1.set_ylabel('Cumulative pnl')
    ax2.set_ylabel('Average pnl')

    ax1.get_shared_x_axes().join(ax1, ax2)
    fig.supxlabel('ts' if over_time else 'trades')
    fig.legend([f't = {delay}' for delay in delay_list])

def run_twosided_perfect_multiple_delays(df_feed, delay_range):
    """
    Get statistics for the perfect strategy for a range of delays

    Arguments
    ---------
    df_feed : pandas.DataFrame
        DSI feed generated by DSI.DSI_Engine
    delay_range : list[int]
        The range of delays to test
    
    Returns
    -------
    tuple[pandas.DataFrame | list[int]]
        A tuple containing:
        * the dataframes of trades executed
        * average pnls per trade
        * median pnls per trade
        * hit ratios
        * win ratios
    
    """
    dfs_trades = run_twosided_perfect(df_feed, delay_range)
    
    cumulative_pnls = []
    average_pnls = []
    median_pnls = []
    trades = []
    hit_ratios = []
    win_ratios = []

    for delay in delay_range:
        df_trades = dfs_trades[delay]
        trades.append(df_trades)
        cumulative_pnls.append(df_trades['cumulative_pnl'].iat[-1])
        average_pnls.append(df_trades['avg_pnl_per_trade'].iat[-1])
        median_pnls.append(df_trades[df_trades['isClose']].loc[:,'pnl'].median())

        closed_pnl = df_trades[df_trades['isClose']].pnl
        profit_or_loss = np.sign(closed_pnl)
        hit_ratios.append(closed_pnl[closed_pnl > 0].sum() / np.abs(closed_pnl).sum())
        win_ratios.append((profit_or_loss > 0).mean())

    return trades, cumulative_pnls, average_pnls, median_pnls, hit_ratios, win_ratios


def DSI_MC_single_time_strat(DSIs, delay : int):
    """
    Monte Carlo simulation of perfect strategy

    Arguments
    ---------
    DSIs : list[pandas.DataFrame]
        Array of DSI feeds
    delay : int
        State feed delay

    Returns
    -------
    tuple[pandas.DataFrame | list[int]]
        A tuple containing:
        * the dataframes of trades executed
        * average pnls per trade
        * median pnls per trade
        * hit ratios
        * win ratios
    """
    cumulative_pnls = []
    average_pnls = [] 
    median_pnls = []
    trades = []
    hit_ratios = []
    win_ratios = []

    for DSI_feed in DSIs:
        trades_temp, c_temp, a_temp, m_temp, hr_temp, wr_temp = run_twosided_perfect_multiple_delays(DSI_feed, [delay])
        trades.append(trades_temp)
        cumulative_pnls.append(c_temp)
        average_pnls.append(a_temp)
        median_pnls.append(m_temp)
        hit_ratios.append(hr_temp)
        win_ratios.append(wr_temp)        
    
    cumulative_pnls = np.array(cumulative_pnls).flatten()
    average_pnls = np.array(average_pnls).flatten()
    median_pnls = np.array(median_pnls).flatten()
    hit_ratio_pnls = np.array(hit_ratios).flatten()
    win_ratio_pnls = np.array(win_ratios).flatten()

    
    return trades, cumulative_pnls, average_pnls, median_pnls, hit_ratio_pnls, win_ratio_pnls

def DSI_MC_multiple_times(DSIs, delays : list[int]):
    """
    Monte Carlo simulation of perfect strategy over multiple delays.

    Returns only statistics

    Arguments
    ---------
    DSIs : list[pandas.DataFrame]
        Array of DSI feeds
    delay_range : list[int]
        The range of delays to test

    Returns
    -------
    tuple[list[float]]
        A tuple containing:
        * average pnls per trade
        * hit ratios
        * win ratios
    """
    average_pnls = np.empty((len(DSIs), len(delays)))
    median_pnls = np.empty((len(DSIs), len(delays)))
    hit_rates = np.empty((len(DSIs), len(delays)))
    win_rates = np.empty((len(DSIs), len(delays)))
    for i, DSI_feed in enumerate(DSIs):
        _, _, a_temp, m_temp, hr_temp, wr_temp = run_twosided_perfect_multiple_delays(DSI_feed, delays)
        average_pnls[i] = a_temp
        median_pnls[i] = m_temp
        hit_rates[i] = hr_temp
        win_rates[i] = wr_temp

    return average_pnls, median_pnls, hit_rates, win_rates

def plot_DS_MC_stats(delays, average_pnls, hit_rates, win_rates, DSI_name, timeframe):
    """
    Plots statistics of completed strategy w.r.t delays

    Arguments
    ---------
    delays : list[int]
        The range of delays used
    average_pnl : list[float]
        Average pnls per trade
    hit_rates : list[float]
        Hit ratios
    win_rates : list[float]
        Win ratios
    DSI_name : str
        DSI type
    timeframe : str
        DSI timeframe
    """
    mean_averages = average_pnls.mean(axis=0)
    median_averages = np.median(average_pnls, axis=0)
    hit_rates_averages = hit_rates.mean(axis=0)
    win_rates_averages = win_rates.mean(axis=0)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (15, 4))
    ax1.plot(delays, mean_averages)
    ax1.plot(delays, median_averages)
    ax1.axhline(0, linestyle = '--', color = 'red')
    ax1.legend(['mean', 'median'])
    ax1.set_ylabel('average pnl per trade')
    ax1.set_xlabel('delay (s)')

    ax2.plot(delays, hit_rates_averages)
    ax2.plot(delays, win_rates_averages)
    ax2.axhline(0.5, linestyle = '--', color = 'red')
    ax2.legend(['hit rate', 'win rate'])
    ax2.set_ylabel('x rate')
    ax2.set_xlabel('delay (s)')
    fig.suptitle(f'{DSI_name} MC - multiple delay strategy statistics ({timeframe} timeframe)')
