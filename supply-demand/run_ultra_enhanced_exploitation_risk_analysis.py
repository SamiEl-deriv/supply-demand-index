
import sys
import os
import json
from datetime import datetime
from engine import SupplyDemandIndexEngine
# Import functions from the original vol75 analysis
import sys
import os
import glob
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, Any, List, Tuple

# Simple exploitation strategies
class SimpleExploitationStrategies:
    @staticmethod
    def momentum_strategy(price_history: np.ndarray) -> str:
        """Simple momentum strategy"""
        if len(price_history) < 5:
            return "hold"
        
        recent_return = (price_history[-1] - price_history[-5]) / price_history[-5]
        if recent_return > 0.01:  # 1% threshold
            return "buy"
        elif recent_return < -0.01:
            return "sell"
        else:
            return "hold"
    
    @staticmethod
    def mean_reversion_strategy(price_history: np.ndarray) -> str:
        """Simple mean reversion strategy"""
        if len(price_history) < 10:
            return "hold"
        
        mean_price = np.mean(price_history[-10:])
        current_price = price_history[-1]
        
        deviation = (current_price - mean_price) / mean_price
        if deviation > 0.02:  # 2% above mean
            return "sell"
        elif deviation < -0.02:  # 2% below mean
            return "buy"
        else:
            return "hold"
    
    @staticmethod
    def volatility_breakout_strategy(price_history: np.ndarray) -> str:
        """Simple volatility breakout strategy"""
        if len(price_history) < 20:
            return "hold"
        
        returns = np.diff(price_history[-20:]) / price_history[-20:-1]
        volatility = np.std(returns)
        recent_return = (price_history[-1] - price_history[-2]) / price_history[-2]
        
        if abs(recent_return) > 2 * volatility:
            if recent_return > 0:
                return "buy"
            else:
                return "sell"
        else:
            return "hold"
    
    @staticmethod
    def exposure_following_strategy(exposure_history: np.ndarray) -> str:
        """Strategy that follows exposure patterns"""
        if len(exposure_history) < 3:
            return "hold"
        
        recent_exposure = exposure_history[-1]
        if recent_exposure > 50000:  # High positive exposure
            return "sell"  # Bet against the crowd
        elif recent_exposure < -50000:  # High negative exposure
            return "buy"   # Bet against the crowd
        else:
            return "hold"

def load_vol75_trade_data() -> pd.DataFrame:
    """Load Vol 75 trade data from CSV files"""
    data_dir = "/Users/samielmokh/Downloads/data/trade/vol_75"
    
    # Get all CSV files
    csv_files = glob.glob(f"{data_dir}/*.csv")
    csv_files.sort()

    print(f"Found {len(csv_files)} CSV files")

    # Load and combine data
    dfs = []
    for i, file in enumerate(csv_files):
        print(f"Loading file {i + 1}/{len(csv_files)}: {os.path.basename(file)}")
        try:
            df = pd.read_csv(file)
            dfs.append(df)
        except Exception as e:
            print(f"Error loading {file}: {e}")
            continue

    if not dfs:
        raise ValueError("No data files could be loaded")

    # Combine all data
    combined_df = pd.concat(dfs, ignore_index=True)

    # Convert timestamp with mixed format handling
    combined_df["time_deal"] = pd.to_datetime(combined_df["time_deal"], format="mixed")

    # Sort by timestamp
    combined_df = combined_df.sort_values("time_deal").reset_index(drop=True)

    print(f"Loaded {len(combined_df):,} total trades")
    print(f"Date range: {combined_df['time_deal'].min()} to {combined_df['time_deal'].max()}")

    # Create a standardized format for our analysis
    trades_df = pd.DataFrame()
    trades_df["timestamp"] = combined_df["time_deal"]

    # Convert action (0=buy, 1=sell) to direction string
    trades_df["action"] = combined_df["action"].map({0: "buy", 1: "sell"})

    # Use volume_usd as amount
    trades_df["amount"] = combined_df["volume_usd"]

    return trades_df

def calculate_net_exposure(trades_df: pd.DataFrame, window_minutes: int = 5) -> pd.Series:
    """Calculate net exposure in time windows"""
    print(f"Calculating net exposure with {window_minutes}min windows...")
    
    # Create time windows
    start_time = trades_df['timestamp'].min()
    end_time = trades_df['timestamp'].max()
    
    time_windows = pd.date_range(
        start=start_time.floor(f'{window_minutes}min'),
        end=end_time.ceil(f'{window_minutes}min'),
        freq=f'{window_minutes}min'
    )
    
    exposure_data = []
    
    for i in range(len(time_windows) - 1):
        window_start = time_windows[i]
        window_end = time_windows[i + 1]
        
        # Filter trades in this window
        window_trades = trades_df[
            (trades_df['timestamp'] >= window_start) & 
            (trades_df['timestamp'] < window_end)
        ]
        
        if len(window_trades) > 0:
            # Calculate net exposure (buy_amount - sell_amount)
            buy_amount = window_trades[window_trades['action'] == 'buy']['amount'].sum()
            sell_amount = window_trades[window_trades['action'] == 'sell']['amount'].sum()
            net_exposure = buy_amount - sell_amount
            exposure_data.append(net_exposure)
    
    exposure_series = pd.Series(exposure_data)
    print(f"Generated {len(exposure_series)} time windows with trades")
    print(f"Exposure range: {exposure_series.min():,.0f} to {exposure_series.max():,.0f}")
    
    return exposure_series

def calculate_broker_risk_metrics(results: Dict[str, Any]) -> Dict[str, float]:
    """Calculate broker risk metrics from strategy results"""
    
    # Extract key metrics
    strategy_returns = []
    strategy_success_rates = []
    spread_impacts = []
    max_profits = []
    
    for strategy_name, strategy_results in results.items():
        strategy_returns.append(strategy_results['mean_return'])
        strategy_success_rates.append(strategy_results['success_rate'])
        spread_impacts.append(strategy_results['mean_spread_impact'])
        max_profits.append(strategy_results['max_profit'])
    
    # Calculate overall risk metrics
    avg_return = np.mean(strategy_returns)
    max_return = max(strategy_returns)
    avg_success_rate = np.mean(strategy_success_rates)
    max_success_rate = max(strategy_success_rates)
    avg_spread_impact = np.mean(spread_impacts)
    max_exploitation_loss = max(max_profits)
    
    # Calculate overall exploitation risk (0-100 scale)
    # Higher returns and success rates = higher risk for broker
    return_risk = min(max_return * 100, 50)  # Cap at 50 points
    success_risk = max_success_rate * 30     # Up to 30 points
    consistency_risk = (1 - np.std(strategy_returns)) * 20  # Up to 20 points
    
    overall_risk = return_risk + success_risk + consistency_risk
    overall_risk = max(0, min(100, overall_risk))  # Clamp to 0-100
    
    return {
        'overall_exploitation_risk': overall_risk,
        'avg_return': avg_return,
        'max_return': max_return,
        'avg_success_rate': avg_success_rate,
        'max_success_rate': max_success_rate,
        'spread_effectiveness': avg_spread_impact,
        'max_exploitation_loss': max_exploitation_loss
    }
import numpy as np
import pandas as pd
from typing import Dict, Any

class RealisticSpreadModel:
    """
    Realistic spread model based on actual broker spreads
    For Vol 75 index (~100,000 value):
    - Normal spread: $4 (0.004%)
    - Trending spread: $20 (0.02%)
    """
    
    def __init__(self, 
                 index_value: float = 100000,      # Typical Vol 75 value
                 normal_spread_dollars: float = 4,  # $4 normal spread
                 trend_spread_dollars: float = 20,  # $20 trending spread
                 trend_threshold: float = 0.002,    # 0.2% threshold for trend detection
                 trend_consistency_required: int = 3):  # Need 3 consecutive moves
        
        self.index_value = index_value
        self.normal_spread_dollars = normal_spread_dollars
        self.trend_spread_dollars = trend_spread_dollars
        self.trend_threshold = trend_threshold
        self.trend_consistency_required = trend_consistency_required
        
        # Convert dollar spreads to percentages
        self.normal_spread_pct = normal_spread_dollars / index_value
        self.trend_spread_pct = trend_spread_dollars / index_value
        
    def detect_trend(self, price_history: np.ndarray) -> str:
        """
        Detect if market is trending based on recent price movements
        
        Returns:
        --------
        str: 'uptrend', 'downtrend', or 'sideways'
        """
        if len(price_history) < self.trend_consistency_required + 1:
            return 'sideways'
        
        # Calculate recent returns
        recent_returns = []
        for i in range(self.trend_consistency_required):
            ret = (price_history[-(i+1)] - price_history[-(i+2)]) / price_history[-(i+2)]
            recent_returns.append(ret)
        
        # Check for consistent trend
        positive_moves = sum(1 for ret in recent_returns if ret > self.trend_threshold)
        negative_moves = sum(1 for ret in recent_returns if ret < -self.trend_threshold)
        
        if positive_moves >= self.trend_consistency_required:
            return 'uptrend'
        elif negative_moves >= self.trend_consistency_required:
            return 'downtrend'
        else:
            return 'sideways'
    
    def calculate_spread(self, price_history: np.ndarray, trade_direction: str) -> float:
        """
        Calculate realistic spread based on market conditions and trade direction
        
        Parameters:
        -----------
        price_history : np.ndarray
            Recent price history
        trade_direction : str
            'buy', 'sell', or 'hold'
            
        Returns:
        --------
        float
            Spread as percentage of index value
        """
        if trade_direction == 'hold':
            return self.normal_spread_pct
        
        # Detect market trend
        trend = self.detect_trend(price_history)
        
        # Base spread
        if trend == 'sideways':
            base_spread = self.normal_spread_pct
        else:
            base_spread = self.trend_spread_pct
        
        # Apply directional bias (brokers widen spreads against trend-following)
        if trend == 'uptrend' and trade_direction == 'buy':
            # Buying in uptrend - broker increases spread
            final_spread = base_spread * 1.5
        elif trend == 'downtrend' and trade_direction == 'sell':
            # Selling in downtrend - broker increases spread
            final_spread = base_spread * 1.5
        else:
            # Counter-trend or sideways - normal spread
            final_spread = base_spread
        
        return final_spread
    
    def apply_spread_to_price(self, mid_price: float, spread_pct: float, trade_direction: str) -> float:
        """
        Apply spread to get execution price
        
        Parameters:
        -----------
        mid_price : float
            Mid market price
        spread_pct : float
            Spread as percentage
        trade_direction : str
            'buy' or 'sell'
            
        Returns:
        --------
        float
            Execution price (ask for buy, bid for sell)
        """
        half_spread = spread_pct / 2
        
        if trade_direction == 'buy':
            return mid_price * (1 + half_spread)  # Pay ask price
        elif trade_direction == 'sell':
            return mid_price * (1 - half_spread)  # Receive bid price
        else:
            return mid_price


def simulate_exploitation_strategies_with_3tick_delay_and_realistic_spreads(
    engine,
    exposure_data: pd.Series,
    spread_model: RealisticSpreadModel,
    initial_capital: float = 100000,
    position_size: float = 10000,
    num_simulations: int = 10
) -> Dict[str, Any]:
    """
    Simulate exploitation strategies with 3-tick delay and realistic spreads
    """
    print("Simulating exploitation strategies with 3-tick delay and realistic spreads...")
    
    strategies = {
        'momentum': SimpleExploitationStrategies.momentum_strategy,
        'mean_reversion': SimpleExploitationStrategies.mean_reversion_strategy,
        'volatility_breakout': SimpleExploitationStrategies.volatility_breakout_strategy,
        'exposure_following': SimpleExploitationStrategies.exposure_following_strategy
    }
    
    results = {}
    
    for strategy_name, strategy_func in strategies.items():
        print(f"  Testing {strategy_name} strategy with ultra protection...")
        
        strategy_results = []
        
        for sim in range(num_simulations):
            np.random.seed(42 + sim)
            
            # Sample exposure data
            if len(exposure_data) > 100:
                sample_indices = np.random.choice(len(exposure_data), size=100, replace=False)
                sampled_exposure = exposure_data.iloc[sample_indices].values
            else:
                sampled_exposure = exposure_data.values
            
            # Initialize tracking variables
            price_history = [engine.S_0]
            exposure_history = []
            positions = []
            pnl_history = [0]
            spread_history = []
            signal_history = []  # Track signals for 3-tick delay
            current_position = 0
            total_spread_cost = 0
            entry_price = 0  # Track actual entry price (with spread)
            unrealized_pnl = 0
            
            for i, exposure in enumerate(sampled_exposure):
                # Generate next price
                prob = engine.exposure_to_probability(exposure)
                drift = engine.compute_mu_from_probability(prob)
                
                # Generate more realistic price changes using GBM
                dt_scaled = 1.0 / (24 * 12)  # 5-minute intervals as fraction of day
                drift_term = (drift - 0.5 * engine.sigma**2) * dt_scaled
                diffusion_term = engine.sigma * np.sqrt(dt_scaled) * np.random.normal(0, 1)
                log_return = drift_term + diffusion_term
                new_price = price_history[-1] * np.exp(log_return)
                
                price_history.append(new_price)
                exposure_history.append(exposure)
                
                # Generate signal for FUTURE tick (3-tick delay)
                if strategy_name == 'exposure_following':
                    current_signal = strategy_func(np.array(exposure_history))
                else:
                    current_signal = strategy_func(np.array(price_history))
                
                signal_history.append(current_signal)
                
                # Execute trade based on signal from 3 ticks ago (3-tick delay)
                if i >= 3:  # Need at least 3 previous signals
                    delayed_signal = signal_history[i-3]  # Use signal from 3 ticks ago
                    
                    # Handle position changes with proper spread application
                    if delayed_signal == "buy" and current_position <= 0:
                        # Close existing short position first (if any)
                        if current_position < 0:
                            close_spread = spread_model.calculate_spread(
                                np.array(price_history[:-3]), 'buy'  # Buying to close short
                            )
                            close_price = spread_model.apply_spread_to_price(new_price, close_spread, 'buy')
                            close_cost = (close_price - new_price) * abs(current_position)
                            total_spread_cost += close_cost
                            spread_history.append(close_spread)
                        
                        # Open new long position
                        open_spread = spread_model.calculate_spread(
                            np.array(price_history[:-3]), 'buy'
                        )
                        open_price = spread_model.apply_spread_to_price(new_price, open_spread, 'buy')
                        current_position = position_size / open_price
                        open_cost = (open_price - new_price) * current_position
                        total_spread_cost += open_cost
                        spread_history.append(open_spread)
                        
                    elif delayed_signal == "sell" and current_position >= 0:
                        # Close existing long position first (if any)
                        if current_position > 0:
                            close_spread = spread_model.calculate_spread(
                                np.array(price_history[:-3]), 'sell'  # Selling to close long
                            )
                            close_price = spread_model.apply_spread_to_price(new_price, close_spread, 'sell')
                            close_cost = (new_price - close_price) * current_position
                            total_spread_cost += close_cost
                            spread_history.append(close_spread)
                        
                        # Open new short position
                        open_spread = spread_model.calculate_spread(
                            np.array(price_history[:-3]), 'sell'
                        )
                        open_price = spread_model.apply_spread_to_price(new_price, open_spread, 'sell')
                        current_position = -position_size / open_price
                        open_cost = (new_price - open_price) * abs(current_position)
                        total_spread_cost += open_cost
                        spread_history.append(open_spread)
                        
                    elif delayed_signal == "hold" and current_position != 0:
                        # Close any existing position
                        if current_position > 0:  # Close long
                            close_spread = spread_model.calculate_spread(
                                np.array(price_history[:-3]), 'sell'
                            )
                            close_price = spread_model.apply_spread_to_price(new_price, close_spread, 'sell')
                            close_cost = (new_price - close_price) * current_position
                            total_spread_cost += close_cost
                            spread_history.append(close_spread)
                        elif current_position < 0:  # Close short
                            close_spread = spread_model.calculate_spread(
                                np.array(price_history[:-3]), 'buy'
                            )
                            close_price = spread_model.apply_spread_to_price(new_price, close_spread, 'buy')
                            close_cost = (close_price - new_price) * abs(current_position)
                            total_spread_cost += close_cost
                            spread_history.append(close_spread)
                        
                        current_position = 0
                    
                    else:
                        # No trade executed, but still track spread for analysis
                        if len(price_history) > 3:
                            current_spread = spread_model.calculate_spread(
                                np.array(price_history[:-3]), 'hold'
                            )
                            spread_history.append(current_spread)
                
                positions.append(current_position)
                
                # Calculate PnL (using mid price for mark-to-market)
                if i > 0:
                    price_change_pct = (new_price - price_history[-2]) / price_history[-2]
                    position_pnl = current_position * price_change_pct * price_history[-2]
                    pnl_history.append(pnl_history[-1] + position_pnl)
            
            # Adjust final PnL for spread costs
            final_pnl_before_spread = pnl_history[-1] if pnl_history else 0
            final_pnl_after_spread = final_pnl_before_spread - total_spread_cost
            
            # Calculate performance metrics
            total_return = final_pnl_after_spread / initial_capital
            max_drawdown = min(pnl_history) / initial_capital if pnl_history else 0
            volatility = np.std(np.diff(pnl_history)) / initial_capital if len(pnl_history) > 1 else 0
            
            # Calculate Sharpe ratio
            if volatility > 0:
                sharpe_ratio = total_return / volatility
            else:
                sharpe_ratio = 0
            
            # Calculate spread impact
            spread_impact = total_spread_cost / initial_capital
            avg_spread = np.mean(spread_history) if spread_history else 0
            
            strategy_results.append({
                'total_return': total_return,
                'total_return_before_spread': final_pnl_before_spread / initial_capital,
                'spread_impact': spread_impact,
                'max_drawdown': max_drawdown,
                'volatility': volatility,
                'sharpe_ratio': sharpe_ratio,
                'final_pnl': final_pnl_after_spread,
                'final_pnl_before_spread': final_pnl_before_spread,
                'total_spread_cost': total_spread_cost,
                'avg_spread': avg_spread,
                'num_trades': len([p for p in positions if p != 0]),
                'price_history': price_history,
                'pnl_history': pnl_history,
                'spread_history': spread_history
            })
        
        # Aggregate results
        results[strategy_name] = {
            'mean_return': np.mean([r['total_return'] for r in strategy_results]),
            'mean_return_before_spread': np.mean([r['total_return_before_spread'] for r in strategy_results]),
            'mean_spread_impact': np.mean([r['spread_impact'] for r in strategy_results]),
            'mean_sharpe': np.mean([r['sharpe_ratio'] for r in strategy_results]),
            'mean_max_drawdown': np.mean([r['max_drawdown'] for r in strategy_results]),
            'success_rate': len([r for r in strategy_results if r['total_return'] > 0]) / len(strategy_results),
            'success_rate_before_spread': len([r for r in strategy_results if r['total_return_before_spread'] > 0]) / len(strategy_results),
            'max_profit': max([r['final_pnl'] for r in strategy_results]),
            'min_profit': min([r['final_pnl'] for r in strategy_results]),
            'avg_spread': np.mean([r['avg_spread'] for r in strategy_results]),
            'individual_results': strategy_results
        }
        
        print(f"    Mean return (after spread): {results[strategy_name]['mean_return']:.2%}")
        print(f"    Mean return (before spread): {results[strategy_name]['mean_return_before_spread']:.2%}")
        print(f"    Spread impact: {results[strategy_name]['mean_spread_impact']:.2%}")
        print(f"    Success rate (after spread): {results[strategy_name]['success_rate']:.1%}")
        print(f"    Average spread: {results[strategy_name]['avg_spread']:.4%}")
    
    return results


def main():
    print("Starting Ultra Enhanced Exploitation Risk Analysis...")
    print("This analysis includes 3-tick delay and realistic broker spreads.")
    print()
    
    print("=" * 80)
    print("ULTRA ENHANCED EXPLOITATION RISK ANALYSIS")
    print("Focus on Real-World Broker Protection with 3-Tick Delay")
    print("=" * 80)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    print(f"Analysis started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    # Step 1: Load trade data
    print("STEP 1: LOADING VOL 75 TRADE DATA")
    print("-" * 40)
    try:
        trades_df = load_vol75_trade_data()
        print(f"✓ Successfully loaded {len(trades_df):,} trades")
        print()
    except Exception as e:
        print(f"✗ Error loading trade data: {e}")
        return
    
    # Step 2: Calculate exposure
    print("STEP 2: CALCULATING NET EXPOSURE")
    print("-" * 40)
    try:
        exposure_data = calculate_net_exposure(trades_df)
        print(f"✓ Calculated exposure for {len(exposure_data)} time windows")
        print(f"✓ Exposure range: {exposure_data.min():,.0f} to {exposure_data.max():,.0f}")
        print()
    except Exception as e:
        print(f"✗ Error calculating exposure: {e}")
        return
    
    # Step 3: Initialize baseline engine
    print("STEP 3: INITIALIZING BASELINE ENGINE")
    print("-" * 40)
    try:
        engine = SupplyDemandIndexEngine(
            sigma=0.30,      # 30% volatility
            scale=150000,    # Scale parameter
            k=0.40,          # ±40% range
            smoothness_factor=2.0,  # Smoothness parameter
            noise_injection_level=0.01  # 1% noise
        )
        print("✓ Baseline engine initialized:")
        print(f"  • σ (volatility): {engine.sigma*100:.1f}%")
        print(f"  • Scale: {engine.scale:,}")
        print(f"  • k (range): ±{engine.k*100:.1f}%")
        print(f"  • Smoothness: {engine.smoothness_factor}")
        print(f"  • Noise injection: {engine.noise_injection_level*100:.1f}%")
        print()
    except Exception as e:
        print(f"✗ Error initializing engine: {e}")
        return
    
    # Step 4: Initialize realistic spread model
    print("STEP 4: INITIALIZING REALISTIC SPREAD MODEL")
    print("-" * 40)
    try:
        spread_model = RealisticSpreadModel(
            index_value=5000,                     # Vol 75 typical value
            normal_spread_dollars=3,              # $3 normal spread (increased)
            trend_spread_dollars=15,              # $15 trending spread (increased)
            trend_threshold=0.002,                # 0.2% trend threshold
            trend_consistency_required=3          # 3 consecutive moves for trend
        )
        print("✓ Realistic spread model initialized:")
        print(f"  • Index value: ${spread_model.index_value:,}")
        print(f"  • Normal spread: ${spread_model.normal_spread_dollars} ({spread_model.normal_spread_pct*100:.3f}%)")
        print(f"  • Trending spread: ${spread_model.trend_spread_dollars} ({spread_model.trend_spread_pct*100:.3f}%)")
        print(f"  • Trend threshold: {spread_model.trend_threshold*100:.1f}%")
        print(f"  • Max spread (trend + directional): ${spread_model.trend_spread_dollars * 1.5:.1f}")
        print()
    except Exception as e:
        print(f"✗ Error initializing spread model: {e}")
        return
    
    # Step 5: Test exploitation with ultra enhanced protection
    print("STEP 5: TESTING EXPLOITATION WITH ULTRA ENHANCED PROTECTION")
    print("-" * 40)
    try:
        ultra_results = simulate_exploitation_strategies_with_3tick_delay_and_realistic_spreads(
            engine=engine,
            exposure_data=exposure_data,
            spread_model=spread_model,
            initial_capital=100000,
            position_size=10000,
            num_simulations=10
        )
        
        print("Ultra enhanced exploitation results (3-tick delay + realistic spreads):")
        for strategy_name, results in ultra_results.items():
            print(f"  {strategy_name}:")
            print(f"    • Mean return (after spread): {results['mean_return']:.2%}")
            print(f"    • Mean return (before spread): {results['mean_return_before_spread']:.2%}")
            print(f"    • Spread impact: {results['mean_spread_impact']:.2%}")
            print(f"    • Success rate (after spread): {results['success_rate']:.1%}")
            print(f"    • Average spread: {results['avg_spread']:.4%}")
        print()
    except Exception as e:
        print(f"✗ Error in ultra enhanced exploitation testing: {e}")
        return
    
    # Step 6: Calculate ultra enhanced risk metrics
    print("STEP 6: CALCULATING ULTRA ENHANCED RISK METRICS")
    print("-" * 40)
    try:
        risk_metrics = calculate_broker_risk_metrics(ultra_results)
        
        ultra_risk_score = risk_metrics['overall_exploitation_risk']
        
        print(f"Ultra enhanced broker risk score: {ultra_risk_score:.1f}/100")
        print()
    except Exception as e:
        print(f"✗ Error calculating risk metrics: {e}")
        return
    
    # Step 7: Generate comprehensive assessment
    print("STEP 7: GENERATING ULTRA ENHANCED RISK ASSESSMENT")
    print("-" * 40)
    
    # Determine risk level
    if ultra_risk_score < 15:
        risk_level = "✅ VERY LOW"
    elif ultra_risk_score < 25:
        risk_level = "✅ LOW"
    elif ultra_risk_score < 40:
        risk_level = "⚠️ MEDIUM"
    else:
        risk_level = "🔴 HIGH"
    
    # Determine spread effectiveness
    avg_spread_impact = risk_metrics['spread_effectiveness']
    if avg_spread_impact > 0.02:  # 2% impact is ultra effective
        spread_effectiveness = "🟢 ULTRA EFFECTIVE"
    elif avg_spread_impact > 0.01:  # 1% impact is highly effective
        spread_effectiveness = "🟢 HIGHLY EFFECTIVE"
    elif avg_spread_impact > 0.005:  # 0.5% impact is moderately effective
        spread_effectiveness = "🟡 MODERATELY EFFECTIVE"
    else:
        spread_effectiveness = "🔴 MINIMALLY EFFECTIVE"
    
    # Step 8: Final summary
    print("STEP 8: FINAL SUMMARY")
    print("-" * 40)
    print("✓ Ultra Enhanced Exploitation Risk Analysis completed successfully!")
    print()
    print("Key Findings:")
    print(f"  • Ultra enhanced broker risk: {ultra_risk_score:.1f}/100")
    print(f"  • Average spread impact: {avg_spread_impact:.2%}")
    print(f"  • Maximum potential loss: ${risk_metrics['max_exploitation_loss']:,.0f}")
    print(f"  • Spread effectiveness: {spread_effectiveness}")
    print()
    print(f"Final Broker Risk Level: {risk_level}")
    print()
    
    print("=" * 80)
    print(f"Analysis completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 80)
    print()
    
    print("=" * 60)
    print("ULTRA ENHANCED EXPLOITATION RISK ANALYSIS COMPLETED!")
    print("=" * 60)
    print(f"Final Risk Level: {risk_level.split()[1] if len(risk_level.split()) > 1 else risk_level}")
    print(f"Spread Effectiveness: {spread_effectiveness}")
    print("3-tick delay + realistic spreads provide real-world broker protection.")


if __name__ == "__main__":
    main()
